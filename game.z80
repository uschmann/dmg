; defines
DEFAULT_LIFES 	EQU	3	; The number of lifes when the game start
DEFAULT_X		EQU	0	; The start position for _X
DEFAULT_Y		EQU	17	; The start address for _Y
DEFAULT_SPEED	EQU	40	; Default speed the of the blocks
DEFAULT_BLOCKS	EQU	4	; Number of blocks to start with

DIR_LEFT		EQU	0 	; Constant for left direction 
DIR_RIGHT		EQU	1 	; Constant for right direction 
BOARD_WIDTH		EQU	15	; Width of the game field
GOAL_Y		EQU	7	; The level is finished if y is == GOAL_Y

; constant data
TXT_LIFES
	DB	"LIFES:"
TXT_LIFES_END

; **
; Starts a new game
; **
startGame:
	call	initGame
	jp	gameLoop

; **
; Initialises the game
; **
initGame:
	ld	a,DEFAULT_LIFES	; set number of lifes
	ld	[_LIFES],a

	ld	a,DEFAULT_X		; set the start x position
	ld	[_X],a
	ld	[_X+1],a

	ld	a,DEFAULT_Y		; set the start y position
	ld	[_Y],a		

	ld	a,DEFAULT_SPEED
	ld	[_SPEED],a

	ld	a,DIR_RIGHT		; Set the moving direction
	ld	[_DIRECTION],a

	ld	a,DEFAULT_BLOCKS	; Set the number of blocks
	ld	[_BLOCKS],a
	ret

; **
; The main game loop
; **
gameLoop:
	call 	readInput		; read Input
	call	gameLogic		; game logic is here
	call	drawView		; draw the game screen
	jr	gameLoop

; **
; Reads user input from the keypad and stores the state of the buttons in _PAD
; **
readInput:
	call	readPad		; read the status of the buttons
	ret

; **
; Updates model value and sets the state of the game
; **
gameLogic:
	call	checkCollision
	call	moveBlocks
	ld	a,[_PAD_DOWN]		; if(_PAD != 0) setBlocks()
	ld	b,KEY_A
	and	b
	cp	0
	call	nz,setBlocks

	call	checkGameOver
	ret

; **
; Checks if the game is over (_LIFES == 0)
; **
checkGameOver:
	ld	a,[_LIFES]		; For now we simply return to the title
	cp	0
	jp	z,begin
	ret

; **
; Sets the blocks at the current position
; **
setBlocks:
	ld	a,[_Y]
	cp	DEFAULT_Y			; Check if we are at the bottom. We can place the blocks everywhere
	jr	nz,.notOnFirstLine
	dec	a			
	ld	[_Y],a
	ld	a,0				; reset x to 0
	ld	[_X],a
	ld	[_X+1],a
	ret
.notOnFirstLine:				; Check if the blocks were set successfully
	call	checkForFail
	cp	0
	jr	z,.failedToSetBlocks
.successSetBlocks:			; Blocks were set successfully
	ld	a,[_Y]
	dec	a				; go to next line
	ld	[_Y],a

	ld	a,0
	ld	[_X+1],a
	ret
.failedToSetBlocks:			; Failed to place the blogs.
	call	flipBgPallete
	ld	b,$A0
	call	simpleDelay
	call	flipBgPallete
	ld	a,0				; reset x to 0
	ld	[_X],a
	ld	[_X+1],a

	ld	a,[_BLOCKS]			; Decrement the number of Blogs
	dec	a
	ld	[_BLOCKS],a

	cp	0				; Check if blocks == 0
	jr	z,.noMoreBlocks
	ret
.noMoreBlocks:
	ld	a,[_LIFES]			; _LIFES--
	dec	a
	ld	[_LIFES],a
	call	resetLevel
	ret

; **
; Restarts the current level
; **
resetLevel:
	call	clearScreen
	ld	a,DEFAULT_X		; set the start x position
	ld	[_X],a

	ld	a,DEFAULT_Y		; set the start y position
	ld	[_Y],a		

	ld	a,DEFAULT_SPEED	; set the speed
	ld	[_SPEED],a

	ld	a,DIR_RIGHT		; Set the moving direction
	ld	[_DIRECTION],a

	ld	a,DEFAULT_BLOCKS	; Set the number of blocks
	ld	[_BLOCKS],a
	ret

; **
; Check if the user failed at placing the blocks
; OUTPUT: a == 0 if fail else a == 1
; **
checkForFail:
	call	waitForVblank
	ld	a,[_BLOCKS]
	ld	c,a
.forEachBlock:			; Check to see if each block is stacked on another
	ld	a,[_X+1]		
	ld	b,a
	ld	a,[_Y]
	inc	a
	call	coordsToAdress0
	ld	a,[hl]

	cp	1			; Check if there is a block
	jr	nz,.failedToSet
.successToSet:
	inc	b
	dec	c
	jp	nz,.forEachBlock	; Check next blog
	ld	a,1			; All blogs placed correct
	ret
.failedToSet:
	ld	a,0
	ret

; **
; Checks if collision with borders of game field accoured and flips the moving direction accordingly
; **
checkCollision:
	ld	a,[_DIRECTION]
	cp	DIR_RIGHT
	jr	z,.checkCollisionRight
.checkCollisionLeft:
	ld	a,[_X+1]		; Set direction to right if _X == 0
	cp	0
	ret	nz
	ld	a,DIR_RIGHT
	ld	[_DIRECTION],a
	ret
.checkCollisionRight:
	ld	a,[_BLOCKS]		; store number of _BLOCKS in b
	ld	b,a
	ld	a,[_X+1]
	add	b			; add _BLOCKS to _X
	cp	BOARD_WIDTH		; Set direction to left if _BLOCKS + _X == BOARD_WIDTH
	ret	nz
	ld	a,DIR_LEFT
	ld	[_DIRECTION],a
	ret

; **
; Moves the blocks accordingly to the direction
; **
moveBlocks:
	ld	a,[_DIRECTION]
	cp	DIR_RIGHT
	jr	z,.moveRight
.moveLeft:
	ld	a,[_X]	; load x to hl
	ld	l,a
	ld	a,[_X+1]
	ld	h,a
	
	ld	a,[_SPEED]	; load speed to e
	ld	e,a
	
	ld	a,l		; 16 bit substraction hl - e
	sub	a,e		; substract e from low nibble
	ld	[_X],a	; save low nibble
	ld	a,h		; substract carry from high nibble
	sbc	a,0
	ld	[_X+1],a

	ret
.moveRight:
	ld	a,[_X]
	ld	l,a
	ld	a,[_X+1]
	ld	h,a
	
	ld	a,[_SPEED]
	ld	d,0
	ld	e,a
	add	hl,de
	
	ld	a,l
	ld	[_X],a
	ld	a,h
	ld	[_X+1],a
	ret

; **
; Updates the screen according to the model data and game state
; **
drawView:
	call	drawNumberOfLifes
	call	drawBlocks
	ret

; **
; Draws the active blocks
; **
drawBlocks:
	call	waitForVblank	
	ld	a,[_Y]		; Clear line to redraw blocks
	ld	d,0
	ld	e,SCRN_VX_B
	call	DE_Times_A		; _Y * Screen width
	ld	de,_SCRN0
	add	hl,de

	ld	b,SCRN_VX_B
.clearLine:				
	ld	[hl],32
	inc	hl
	dec	b
	jr	nz,.clearLine

	ld	a,[_X+1]		; get Address of bgMap to draw
	ld	b,a
	ld	a,[_Y]
	call	coordsToAdress0

	ld	a,[_BLOCKS]
.drawBlock:
	ld	[hl],1
	inc	hl
	dec	a
	jr	nz,.drawBlock
	ret

drawNumberOfLifes:
	ld	hl, TXT_LIFES			; Display lifes-label
	ld	de, _SCRN0
	ld	bc, TXT_LIFES_END - TXT_LIFES
	call	mem_CopyVRAM

	ld	a,[_LIFES]				; Draw lifes
	ld	c,a				
	ld	d,TXT_LIFES_END - TXT_LIFES 			
	call	printHex

	ret

;**
; Inverts the background color palette
; **
flipBgPallete:
	ld	a,[rBGP]
	xor	$FF
	ld	[rBGP], a	
	ret

simpleDelay:
.loop:
	call	waitForVblank
	dec	b
	jr	nz,.loop
	ret
